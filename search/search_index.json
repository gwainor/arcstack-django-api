{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ArcStack Django API - A REST Framework, Django way","text":"<p>ArcStack Django API is a framework that does not require any learning apart from your Django knowledge.</p> <p>Key Features:</p> <ul> <li>Easy: Uses Django URLs and Class Based Views.</li> <li>Extensible: Powerful middleware system just of API endpoints.</li> <li>Same Context: Does not require to change context like DRF.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install arcstack-django-api\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<p>Create a file to store your API endpoints. <code>endpoints.py</code> is a good choice of name. And create your first endpoint:</p> endpoints.py<pre><code>from arcstack_api import Endpoint\n\n\nclass StatusOk(Endpoint):\n    def get(self, request):\n        return {\"status\": \"OK\"} # (1)!\n</code></pre> <ol> <li>Notice that return is not a <code>HttpResponse</code>. The ArcStack API checks your return type and builds an appropriate <code>HttpResponse</code> object thanks to built-in <code>CommonMiddleware</code>.</li> </ol> <p>Now we have an endpoint, it is time to define the URL.</p> urls.py<pre><code>from django.contrib import admin\nfrom django.urls import path\n\nfrom . import endpoints\n\nurlpatterns = [\n    path(\"admin/\", admin.site.urls),\n    path(\"api/\", endpoints.StatusOk.as_endpoint()),\n]\n</code></pre> <p>You need to use <code>.as_view()</code> in URL patterns When using Django class-based views. The <code>Endpoint</code> structure is same but to differentiate the API endpoints from normal views, you need to use <code>as_endpoint()</code>.</p> <p>To keep the learning curve minimal, the <code>Endpoint</code> is extended from Django's <code>View</code> class and the usage is same.</p>"},{"location":"motivation/","title":"Motivation","text":"<p>There are many API frameworks that designed for Django like Django REST Framework, Django Ninja, and tastypie. You can find many more with a little search on Google.</p> <p>All the API frameworks out there, either have high learning curve, complex built-in systems or different usage than what you used to do with Django views and urls. What if you just want something just simple with powerful extensibility? This is where ArcStack Django API comes in.</p> <p>It has the same powerful middleware system as Django with some API specific tweaks. Without any middleware, the <code>Endpoint</code> class works just like <code>View</code> class of Django.</p> <p>Explore the documentation find out more about the features of ArcStack Django API framework!</p>"},{"location":"roadmap/","title":"Roadmap","text":"<p>In the list below, you can see what features implemented and what to expect in the upcoming releases.</p> <ul> <li> API Middleware system<ul> <li> Async support</li> </ul> </li> <li> Schemas with pydantic<ul> <li> Validating inputs using schemas.</li> <li> Determining which schemas to use with type hinting. Similar to Django Ninja</li> </ul> </li> <li> Authentication<ul> <li> HTTP Header Authorization with <code>Basic</code></li> <li> HTTP Header Authorization with <code>Bearer</code></li> </ul> </li> <li> Pagination, filtering, sorting<ul> <li> Pagination with cursor</li> <li> Pagination with range</li> <li> Sorting</li> <li> Filtering</li> </ul> </li> <li> CRUD helper classes<ul> <li> Built-in endpoint class for creating, updating, deleting, retrieving records</li> </ul> </li> </ul>"},{"location":"middleware/","title":"Middleware","text":"<p>This is the core of ArcStack Django API. The <code>Endpoint</code> is no different than <code>View</code> class of Django without any middleware defined.</p> <p>The middleware system is a shallow copy of the Django middleware system. This is to ensure that when a new middleware needs to be created you don't need to learn a complex system.</p> <p>If you did not meddle into Django Middleware system yet, I suggest to read its documentation first.</p> <p>IMPORTANT: There is no <code>async</code> support yet.</p>"},{"location":"middleware/#defining-middleware","title":"Defining Middleware","text":"<p>The middleware definiton can be changed in Django <code>settings</code>. The setting variable name is <code>API_MIDDLEWARE</code>.</p> <p>ArcStack Django API comes with following setting as default:</p> <pre><code>API_MIDDLEWARE = [\n    \"arcstack_api.middleware.CommonMiddleware\",\n]\n</code></pre>"},{"location":"middleware/#differences-from-django-middleware","title":"Differences from Django Middleware","text":"<p>ArcStack API Middleware works same with Django middleware but there are some differences that you need to be aware of.</p>"},{"location":"middleware/#request-object","title":"Request object","text":"<p>The ArcStack API defines a <code>_arcstack_meta</code> attribute to the incoming <code>HttpRequest</code> object. This object stores the <code>endpoint</code> function and <code>args</code> and <code>kwargs</code> passed from the Django.</p> <p>Django, at the end of the middleware chain, resolves request to get the view function and generates <code>args</code> and <code>kwargs</code> to pass to the view function. These parameters are <code>path</code> parameters.</p> <p>ArcStack API does not re-resolve requests since it is wasteful to do the same operation twice. Instead, it generates a meta object to store the <code>view</code> function, <code>args</code> and <code>kwargs</code> and attaches it to <code>request</code> object. This <code>_arcstack_meta</code> object is removed from the <code>request</code> just before calling <code>process_endpoint</code> and <code>endpoint</code> functions.</p>"},{"location":"middleware/#django-middleware-hooks","title":"Django middleware hooks","text":"<p>Django has some special hooks in the middleware system. For more information, you can visit the Django documentation</p>"},{"location":"middleware/#use-process_endpoint-instead-of-process_view","title":"Use <code>process_endpoint</code> instead of <code>process_view</code>","text":"<p>process_view() middleware hook renamed to <code>process_endpoint</code> but behaves the same. This hook especially useful if you want to have a functionality same as Django Ninja.</p>"},{"location":"middleware/#no-process_template_response-hook","title":"No <code>process_template_response()</code> hook","text":"<p>process_template_response() hook has no use for API endpoints.</p>"},{"location":"middleware/common/","title":"Common Middleware","text":"<p>Import string: <code>arcstack_api.middleware.CommonMiddleware</code></p> <p>Common middleware is the most basic middleware that provides some functionality.</p> <p>While it is not mandatory to use any middleware, it is strongly encouraged to use the <code>CommonMiddleware</code></p>"},{"location":"middleware/common/#no-httpresponse-return-requirement","title":"No HttpResponse return requirement","text":"<p>Django views always must return a <code>HttpResponse</code> object. The common middleware checks your endpoint return and builds the <code>HttpResponse</code> object for you.</p>"},{"location":"middleware/common/#httpresponse","title":"<code>HttpResponse</code>","text":"<p>If the return is a <code>HttpRespose</code> object, nothing will be done.</p>"},{"location":"middleware/common/#basic-types","title":"Basic types","text":"<p><code>str</code>, <code>int</code>, <code>flaot</code>, <code>bool</code> types are converted to string and the content type is set to <code>text/plain</code>.</p>"},{"location":"middleware/common/#list-and-dict","title":"<code>list</code> and <code>dict</code>","text":"<p><code>list</code> and <code>dict</code> objects are serialized to <code>json</code> and the content type is set to <code>application/json</code>.</p>"},{"location":"middleware/common/#other-types","title":"Other types","text":"<p>If the object is serializable with <code>json</code> it will be serialized and the content type will be set to <code>application/json</code>.</p> <p>Any other type will result with a internal server error with status code <code>500</code>.</p>"},{"location":"middleware/common/#login-required-check","title":"Login Required check","text":"<p>The common middleware checks the <code>request.user</code> object if the endpoint is set login required.</p> <p>For class-based endpoints just define a class attribute called <code>LOGIN_REQUIRED</code>.</p> <pre><code>from arcstack_api import Endpoint\n\nclass Sample(Endpoint):\n    LOGIN_REQUIRED = True\n\n    def get(self, request):\n        return {\"status\": \"OK\"}\n</code></pre> <p>For function endpoints, you can define it in the decorator params:</p> <pre><code>from arcstack_api import api_endpoint\n\n@api_endpoint(login_required=True)\ndef sample(request):\n    return {\"status\": \"OK\"}\n</code></pre> <p>For default, all enpoints are set to not login required but this behavior can be change using <code>API_DEFAULT_LOGIN_REQUIRED</code> setting. The default is <code>False</code>. If you set to <code>True</code> all endpoints will require a logged in user. You can still set <code>login_required</code> to <code>False</code> on any endpoint to make it public.</p>"},{"location":"middleware/common/#early-return-with-exceptions","title":"Early return with exceptions","text":"<p>Common middleware supports early returns with exceptions to return a HTTP <code>400</code> error.</p> <pre><code>from arcstack_api import APIError, Endpoint\n\nclass Sample(Endpoint):\n    def get(self, request):\n        ...\n        if some_condition:\n            raise APIError(\"Some condition is not met\")\n\n        return {\"status\": \"OK\"}\n</code></pre> <p>It is also possible to pass any other type like <code>list</code>, <code>dict</code> to <code>APIError</code> to response as a <code>json</code>.</p> <pre><code>from arcstack_api import APIError, Endpoint\n\nclass Sample(Endpoint):\n    def get(self, request):\n        ...\n        if some_condition:\n            raise APIError(\n                {\"error\": \"ugh. some condition has not met\"},\n                status_code=480, # (1)!\n            )\n\n        return {\"status\": \"OK\"}\n</code></pre> <ol> <li>Status code of the APIError is default to <code>400</code> but another response code can be given.</li> </ol> <p>There is also <code>UnauthorizedError</code> that can be raised if user is not authorized to execute the endpoint</p> <pre><code>from arcstack_api import Endpoint, UnauthorizedError\n\nclass Sample(Endpoint):\n    def get(self, request):\n        ...\n        if some_condition:\n            raise UnauthorizedError()\n\n        return {\"status\": \"OK\"}\n</code></pre> <p>And lastly, there is <code>InternalServerError</code> if you want to trigger a <code>500</code> error programmatically.</p>"}]}